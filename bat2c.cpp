#include <windows.h>
#include <fstream>
#include <string>
#include "argparse.hpp"
#define nl std::endl

std::vector<std::string> split(const std::string& s, char seperator) {
	std::vector<std::string> output;
	std::string::size_type prev_pos = 0, pos = 0;
	while ((pos = s.find(seperator, pos)) != std::string::npos) {
		std::string substring(s.substr(prev_pos, pos - prev_pos));
		output.push_back(substring);
		prev_pos = ++pos;
	}
	output.push_back(s.substr(prev_pos, pos - prev_pos));
	return output;
}

std::string lower_s(std::string s) {
	std::string ns;
	for (auto it = s.begin(); it != s.end(); ++it) {
		ns.push_back(std::tolower(*it));
	}
	return ns;
}
std::string string_replace(std::string src, std::string const& target, std::string const& repl) {
	// handle error situations/trivial cases

	if (target.length() == 0) {
		// searching for a match to the empty string will result in 
		//  an infinite loop
		//  it might make sense to throw an exception for this case
		return src;
	}

	if (src.length() == 0) {
		return src;  // nothing to match against
	}

	size_t idx = 0;

	for (;;) {
		idx = src.find(target, idx);
		if (idx == std::string::npos)  break;

		src.replace(idx, target.length(), repl);
		idx += repl.length();
	}

	return src;
}
std::string process(std::string s) { // replace all ", ' and \ to their escaped variants
	return string_replace(s, "\"", "\\\"");
}

int main(int argc, char* argv[]) {
	// do the parsing
	argparse::ArgumentParser program("Bat2C", "1.0 - Stable beta");
	program.add_argument("path")
		.help("The path to your .bat file from the current directory.")
		.required()
		.nargs(1);
	try {
		program.parse_args(argc, argv);
	}
	catch (const std::runtime_error& err) {
		std::cerr << err.what() << nl;
		std::cerr << program;
		std::exit(1);
	}
	// check the file
	std::string path = program.get("path");
	std::ifstream batfile;
	try {
		batfile = std::ifstream(path, std::ios_base::in);
	} catch (const std::ifstream::failure& e) {
		std::cerr << "Could not open a file: " << e.what() << nl;
		std::cerr << program;
		std::exit(1);
	}

	if (!batfile.good()) {
		std::cout << "File not exists or empty!" << nl;
		std::exit(1179208773);
	}

	std::cout << "Found a file: " << path.substr(path.find_last_of("/\\") + 1) << nl;
	std::stringstream _tmp;
	_tmp << batfile.rdbuf();
	std::vector<std::string> batcode = split(_tmp.str(), '\n');

	// do all the "hard" C coding
	std::cout << "Generating the C code..." << nl;
	std::string cp = std::string(); // C Program

	// sorry for that string =)
	cp.append("// AUTO-GENERATED by Bat2C program\n// that was written by blek\n// \n// compile like this(minimum size, but may be hard):\n// cl out.c\n// crinkler [object.obj] user32.lib kernel32.lib\n// \n// or this(bigger size(still pretty small tho), but WAY easier):\n// tcc out.c \n\n#include <stdlib.h>\n\nint main() {\n");
	std::string _tmp2; // used in loop, defined outside so you don't allocate in loop

	for (int i = 0; i < batcode.size(); i++) {
		// as you see, its pretty simple
		_tmp.str(std::string());
		if (lower_s(batcode[i]).starts_with("rem") || lower_s(batcode[i]).starts_with("#") || lower_s(batcode[i]).starts_with("::")) {
			batcode[i].erase(0, 4);
			_tmp << "    // " << process(batcode[i]) << "\n";
		}
		else {
			_tmp << "    system(\"" << process(batcode[i]) << "\");\n";
		}
		cp.append(_tmp.str());
	}
	cp.append("}\n\n");
	std::ofstream outc("out.c");
	outc << cp;
	if (!outc.good()) {
		std::cout << "There was some problem writing to a file, =(" << nl;
		std::cout << "The program: " << nl << cp << nl;
	} else {
		std::cout << "Code generated, file saved to out.c!" << nl;
	}
	outc.close();
	std::cout << "\n\x1b[90mForged by blek! in the depths of hell" << nl; // \x1b[0m
	std::cout << "GitHub source code: https://github.com/b1ek/Bat2C\n\x1b[0m" << nl;

	return 0;
} // main